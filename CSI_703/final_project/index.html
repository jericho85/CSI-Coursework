<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <link rel="stylesheet" href="styles.css">
</head>
<style>


</style>
<h1 class="center">A Framework for Exploring Metadata</h1>
<h2 class="center"> IN TRADING CARD GAMES</h2>
<body class="center">
<b></b> <br><br>
<div>
        <b>Background</b><br><br>
        &nbsp&nbsp&nbsp&nbsp The trading card game, Magic: The Gathering™ (MTG), produced by Wizards of the Coast, LLC, has 
        become one of the largest such games in the world since its inception in 1993. Over that time, 
        it has grown to have 35,000,000 active players (Webb, 2018) who build and compete with 60 cards 
        decks chosen from a set of 19,989 cards (Gamepedia, 2019). The quantity of cards and deck size 
        mean there are 1.226859x10^176 possible combinations in total, not accounting for decks that are 
        non-functional, and not considering sideboards, a second set of cards from which a player can 
        reconstruct a deck mid-tournament. Given the complexity of the game, the rate at which new cards 
        are added, and the element of randomness inherent in games involving shuffled decks of cards, it 
        is unlikely to ever be solved. <br><br>
        
        &nbsp&nbsp&nbsp&nbsp Despite the complexity of the sample space players tend to converge on a subset of cards with 
        preferable properties. This reduces the computational expense of studying the format a great 
        deal while leaving space for interesting questions to arise.<br><br>

        &nbsp&nbsp&nbsp&nbsp The prize pools of tournaments are high enough to encourage such changes in competitive 
        decks despite the costs. Players choose decks based on cost, performance, and some other 
        components this project hopes to move toward identifying. The costs of decks, and of swapping 
        between two decks at a particular time, is estimable given the public market for cards. 
        Performance can be measured to some degree through tournament results, though the random 
        aspect of the game confounds this to some degree. <br><br>

        &nbsp&nbsp&nbsp&nbspThis project aims to build a framework for modeling transitions between decks as an early 
        component in understanding behaviors in this type of sample space. <br><br>

        <b>Research Purpose</b><br><br>

        &nbsp&nbsp&nbsp&nbspStudying behaviors computationally in a large sample space is costly. To reduce costs, 
        ideally exploratory analysis is conducted that identifies the key components that help 
        understand which features of a sample space are interesting and bear further study. 
        This project aims to build a useful tool for identifying these features in the sample 
        space of Magic: the Gathering’s legacy tournament results by visualizing it as a network. 
        Decks with non-zero intersections will have edges that ultimately will bear some cost, 
        while the decks themselves will be the nodes. Visualizing this space as a network allows 
        a researcher to more easily understand a specific player’s available options when making 
        decisions in terms of which decks to play.<br><br>

        &nbsp&nbsp&nbsp&nbspThe next phase of this project will be to add tournament results to nodes. This would 
        allow a researcher to visualize more completely the information that may have contributed 
        to player decisions. An added benefit to publishing such a tool is information transparency 
        for players; by viewing their current deck in this tool, a player could easily determine 
        the cards necessary to transition to other decks which may be more competitive or interesting.<br><br>

        &nbsp&nbsp&nbsp&nbspThe final stage in creating a framework to model the Legacy deck sample space would be to 
        add a temporal component. This would allow a researcher to visualize how changes in costs 
        and tournament performance altered flows across time as shown by the number of players 
        utilizing specific decks. <br><br>
        
        &nbsp&nbsp&nbsp&nbspOnce completed, this tool will make used to identify interesting 
        flows using visual contrast; that is, those that are not explained by some function of 
        cost and performance should carry some visual encoding. This project is ultimately a tool 
        to elucidate further questions by allowing the examination of expected patterns in data 
        and contrasting expectations with observations that is useful in other similarly situated 
        sample spaces. <br><br>

        <b>A Note on Jaccard Similarity</b><br><br>
        &nbsp&nbsp&nbsp&nbspJaccard Similarity is a measure of how alike two sets are. It is calculated as the absolute 
        value of the intersection of the sets divided by the absolute value of the union of the two sets. 
        In this visualization deck lists are sets, thus the Jaccard Similarity is number of matching cards divided by the total number of unique cards across two decks.<br><br>

        <b>Visualization Features</b><br><br>

        <i>&nbsp&nbsp&nbsp&nbspFilter</i><br>
        Filtering is available by card type and card price. When no card type is selected, edges are shown
        if at least 8 cards are shared between any given two decks. For card type selections other than planeswalkers
        edges are shown if at least 4 cards are shared between any two decks. For planeswalkers, any shared cards 
        will generate an edge.

        <br><br><i>&nbsp&nbsp&nbsp&nbspLegend</i><br>
        A legend chart shows the deck types of each node. 

        <br><br><i>&nbsp&nbsp&nbsp&nbspHighlight</i><br>
        Selecting a node will highlight it and all neighbors of the selected node. A reset button is
        available to clear this selection.

        <br><br><i>&nbsp&nbsp&nbsp&nbspTooltips</i><br>
        Hovering over a node will generate a tooltip showing the associated deck name.
        Once a node is highlighted, hovering over an edge will display a statically placed tooltip
        showing the selected deck, neighboring deck connected through the currently hovered edge, and the 
        similarity between the two decks.

        <br><br><i>&nbsp&nbsp&nbsp&nbspData Tables</i><br>
        Highlighting a node also displays the average deck list submitted for that deck name. Selecting an
        additional node will display it and the previously selection in a table allowing deck lists to be compared.



</div>

<br>
<br>

<div>
        <button type="button" onclick="allPrices()">All Prices</button>
        <button type="button" onclick="over5()">Over $5</button>
        <button type="button" onclick="over10()">Over $10</button>
        <button type="button" onclick="over20()">Over $20</button>
        <!--<button type="button" onclick="over50()">Over $50</button>-->
        <button type="button" onclick="over100()">Over $100</button>

        <br><br>
        <div><font color="#faf9f4"> .</font><select>&nbsp &nbsp</select></div>
</div>
<div id="canvas1"></div><br><br><br><br>
<div id="canvas2"></div>
<br><br>

<div>
        <br><br><br><br><br><br><br><br><br><br><br><br>
        <b>Bibliography</b>
        <br><br>Gamepedia. (2019, 2 16). Magic: The Gathering Statistics and Trivia. Retrieved from Gamepedia: https://mtg.gamepedia.com/Magic:_The_Gathering/statistics_and_trivia
        <br><br>Healey, C. G. (2017, Oct 2). Perception in Visualization. Retrieved from NC State University Computer Science: https://www.csc2.ncsu.edu/faculty/healey/PP/index.html
        <br><br>Lopez, L., Guerrero, O., & Axtell, R. (2015, July 1). Retrieved from arXiv.org: https://arxiv.org/pdf/1507.00248.pdf
        <br><br>MTGJSON. (2019, 2 26). MTGJSON. Retrieved from https://mtgjson.com/json/AllCards.json
        <br><br>MTGTop8. (2019, 3 23). Legacy Events. Retrieved from MTGTop8: https://www.mtgtop8.com/format?f=LE
        <br><br>Simons, D. J. (2000). Current Approaches to Change Blindness. Visual Cognition, 1-15.
        <br><br>TCGPlayer. (2019, 2 26). TCGPlayer APIs. Retrieved from TCGPlayer: http://developer.tcgplayer.com/
        <br><br>Webb, K. (2018, 12 18). With more than 35 million players worldwide, Magic the Gathering is giving back to its community with a brand new game and $10 million in esports prize money. Retrieved from Business Insider: https://www.businessinsider.com/magic-the-gathering-announces-10-million-esports-program-for-2019-2018-12
        <br><br>Wizards of the Coast, LLC. (2019, 2 16). Rules | Magic: The Gathering. Retrieved from Wizards: https://magic.wizards.com/en/game-info/gameplay/rules-and-formats/rules
        <br><br>Yee, K.-P., Fisher, D., Dhamija, R., & Hearst, M. (2001). Animated Exploration of Dynamic Graphs with Radial Layout. IEEE Symposium on Visual Information.
        
        
</div>
<br><br><br><br>
<a href = "mailto: jmcleod3@gmu.edu">Send Feedback</a><br><br>
</body>


<script src="d3.js"></script>

<script>
var width = 800,
            height = 680,
            radius = 12,
            x0 = width/2-60,
            y0 = height/2+30,
            r = 300

var svg = d3.select("#canvas1").append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("id","center-me")

var dropDownData1 = ["All Types","Artifacts","Creatures","Enchantments","Instants","Lands","Planeswalkers","Sorceries"]
var dropDownData2 = ["All Prices","Over $5","Over $10","Over $20","Over $50","Over $100"]
input1 = 'data'
input2 = 'all'
var inputdata = '/json/'+input1+'_'+input2+'.json'
console.log(inputdata)
renderPage(inputdata)

function allPrices(){
    input2 = "all"
    var inputdata = '/json/'+input1+'_'+input2+'.json'
    d3.selectAll("svg > *").remove();
    d3.selectAll("#canvas2 > *").remove()
    renderPage(inputdata)
}
function over5(){
    input2 = 'over005'
    var inputdata = '/json/'+input1+'_'+input2+'.json'
    d3.selectAll("svg > *").remove();
    d3.selectAll("#canvas2 > *").remove()
    renderPage(inputdata)
}
function over10(){
    input2 = 'over010'
    var inputdata = '/json/'+input1+'_'+input2+'.json'
    d3.selectAll("svg > *").remove();
    d3.selectAll("#canvas2 > *").remove()
    renderPage(inputdata)
}
function over20(){
    input2 = 'over020'
    var inputdata = '/json/'+input1+'_'+input2+'.json'
    d3.selectAll("svg > *").remove();
    d3.selectAll("#canvas2 > *").remove()
    renderPage(inputdata)
}
function over50(){
    input2 = 'over050'
    var inputdata = '/json/'+input1+'_'+input2+'.json'
    d3.selectAll("svg > *").remove();
    d3.selectAll("#canvas2 > *").remove()
    renderPage(inputdata)
}
function over100(){
    input2 = 'over100'
    var inputdata = '/json/'+input1+'_'+input2+'.json'
    d3.selectAll("svg > *").remove();
    d3.selectAll("#canvas2 > *").remove()
    renderPage(inputdata)
}



var dropdown = d3.select('select')
    .on('change',ondropchange1)

var options = dropdown.selectAll("option").data(dropDownData1).enter()
    .append("option")
    .text(function(d){return d})
    
function ondropchange1() {
    selectValue = d3.select('select').property('value')
    if (selectValue == 'All Types') {
        input1 = 'data'
    } else if (selectValue == 'Artifacts') {
         input1 = 'artifact'
    } else if (selectValue == 'Creatures') {
         input1 = 'creatures'
    } else if (selectValue == 'Enchantments') {
         input1 = 'enchantments'
    } else if (selectValue == 'Instants') {
         input1 = 'instants'
    } else if (selectValue == 'Lands') {
         input1 = 'lands'
    } else if (selectValue == 'Planeswalkers') {
         input1 = 'planeswalker'
    } else if (selectValue == 'Sorceries') {
         input1 = 'sorcery'
    } 
    var inputdata = '/json/'+input1+'_'+input2+'.json'
    //console.log(input1, input2)
    d3.selectAll("svg > *").remove();
    d3.selectAll("#canvas2 > *").remove()
    renderPage(inputdata)

}


function renderPage(inputdata) {
    var data = d3.json(inputdata,function(error, data){
        var nodeData = data["nodes"]
        var linkData = data["links"]
        var deck_lists = data.decks[0]
        var deckHistory = []
        //console.log(data["nodes"])
        //console.log(nodeData)
        //console.log(linkData)
        //console.log(data.decks[0])
        //console.log(deck_lists)


                        //

        var deckNames = ["4-c Control","Affinity","Antiquities War","Arclight Phoenix",
                        "Belcher","Bomberman","BUG Midrange","Burn","Canadian Threshold",
                        "Cloudpost Ramp","Dark Depths","Death and taxes","Death's Shadow",
                        "Delver (Other)","Doomsday","Dragon Stompy","Dredge",
                        "Eldrazi Aggro","Elves","Food Chain","Goblins","Grixis Control",
                        "Grixis Delver","Humans","Infect","Junk","Lands",
                        "Legacy Landstill","LOAM","Maverick","Merfolk","MUD","Nic Fit",
                        "Painter","Pikula","Reanimator","Slivers","Sneak & Show",
                        "Stoneblade","Storm","UR Delver","UWx Control","Zombie Bombardment"]

        var decksJSON = []

        for(var i = 0; i < deckNames.length; i++) {
                var x = x0 + r * Math.cos(2 * Math.PI * i / deckNames.length);
                var y = y0 + r * Math.sin(2 * Math.PI * i /deckNames.length);
                //console.log(x,y)   
                //var deckName = deckNames[i]
                var deckName = nodeData[i]["id"]
                var deckType = nodeData[i]["group"]
                decksJSON.push({
                    id:deckName,
                    group:deckType,
                    x_value : x,
                    y_value : y,
                    rad : radius,
                    color : "blue"
                })
                //createNode(deckName,x,y,radius)
            };
        //console.log(decksJSON)
        //console.log(decksJSON.length)

        //Initial drawing of the graph; written as a function to target with reset button
        function drawNetwork(){
                // create a 'reset' button
                var resetButtonText =  svg.append("text")
                        .attr("x",649)
                        .attr("y",666)
                        .style("font-size","13px")
                        .text("Reset")
                var resetButton = svg.append("rect")
                        .on("click",function(d){redrawGraph()})
                        .attr("x",642)
                        .attr("y",653)
                        .attr("width",52)
                        .attr("height",17)
                        .attr("rx","4")
                        .style("fill","#faf9f4")
                        .style("fill-opacity",0)
                        .style("stroke","grey")
                        .style("stroke")
            // draw legend

            var nodeCircle = svg.append("circle")
                            .attr("cx",600)
                            .attr("cy",10)
                            .attr("r",8)
                            .style("fill","darkblue")
            var nodeCircle = svg.append("circle")
                            .attr("cx",600)
                            .attr("cy",35)
                            .attr("r",8)
                            .style("fill","darkgreen")
            var nodeCircle = svg.append("circle")
                            .attr("cx",600)
                            .attr("cy",60)
                            .attr("r",8)
                            .style("fill","darkred")
            var nodeLabel = svg.append("text")
                            .attr("x",610)
                            .attr("y",13)
                            .text("Aggro")
            var nodeLabel = svg.append("text")
                            .attr("x",610)
                            .attr("y",38)
                            .text("Combo")
            var nodeLabel = svg.append("text")
                            .attr("x",610)
                            .attr("y",63)
                            .text("Control")


            // draw the edges
            for (var i=0; i<linkData.length; i++){
                var deck1 = linkData[i]["source"]
                var deck2 = linkData[i]["target"]
                var strength = linkData[i]["value"]

                // call function to convert jacard's similarity to RGB values
                var x = create_color(strength)
                var color = d3.rgb(x,x,x)
                var deck1Stats = get_coord(deck1)
                //console.log(deck1Stats)
                var deck2Stats = get_coord(deck2)
                //console.log(deck2Stats)
                var x1 = deck1Stats[0]
                var x2 = deck2Stats[0]
                var y1 = deck1Stats[1]
                var y2 = deck2Stats[1]
                //console.log(x1,x2,y1,y2)
                createEdge(x1,y1,x2,y2,color)

                }
            
            // draw the nodes after the edges
            for (var i=0; i<decksJSON.length; i++) {
                var deckname = decksJSON[i]["id"]
                var x = decksJSON[i]["x_value"]
                var y = decksJSON[i]["y_value"]
                var deckType = decksJSON[i]["group"]
                //console.log(deckname,x,y)
                var rad = 10
                createNode(deckname,x,y,rad,deckType)
                }
            }
        
        drawNetwork()

        // redrawing the graph alone is not sufficient; this function just adds 'clear all'
        function redrawGraph() {
            d3.selectAll("svg > *").remove();
            d3.selectAll("#canvas2 > *").remove()
            deckHistory = []
            drawNetwork()
        }

        // Given a deck name, this function loops through the card list and 
        // returns all cards with quant>0 in a new datastructure
        function getDecklist(name) {
            var deckList = []
            var selectedDeck = deck_lists[name][0]
            var count = Object.keys(deck_lists[name][0]).length
            for (var key in selectedDeck){
                if (selectedDeck[key]>0){
                    deckList.push({
                        card:key,
                        quantity:selectedDeck[key] 
                    })
                }
            }
            return(deckList)
        }

        // Tooltip function for mouseover events on nodes
        function tooltip(text,x,y,r) {
            svg.append("rect")
                .attr("x",x+20)
                .attr("y",y-(r/2)-10)
                .attr("width",185)
                .attr("height",30)
                .style("fill","#faf9f4")
                .attr("id","tipbox")
            svg.append("text")
                .attr("x",x+22)
                .attr("y",y-(r/2)+10)
                .attr("id","tiptext")
                .style("font-size","18px")
                .text(text)
        }

        // clear tooltip for mouseout events on nodes
        function cleartip() {
            svg.select("#tipbox").remove()
            svg.select("#tiptext").remove()
        }

        function edgetooltip(deck1,deck2,jacard,neighbors) {
            console.log(deck1,deck2,jacard)
            var round3 = d3.format(".4f")
            jacard = round3(jacard)
            //svg.append("rect")
            //    .attr("x",10)
            //    .attr("y",50)
            //    .attr("width",100)
            //    .attr("height",40)
            //    .style("fill","#fcfbf6")
            //    .attr("id","edgetip")
            svg.append("text")
                .attr("x",12)
                .attr("y",50)
                .attr("id","edgetiptext")
                .style("font-size","14px")
                .text("Selected Deck: " + deck1)
            svg.append("text")
                .attr("x",12)
                .attr("y",70)
                .attr("id","edgetiptext2")
                .style("font-size","14px")
                .text("Neighbor Deck: " + deck2)
            svg.append("text")
                .attr("x",12)
                .attr("y",90)
                .attr("id","edgetiptext3")
                .style("font-size","14px")
                .text("Jacard Similarity: " + jacard)
        }

        function clearEdgeTip() {
            //svg.select("#edgetip").remove()
            svg.select("#edgetiptext").remove()
            svg.select("#edgetiptext2").remove()
            svg.select("#edgetiptext3").remove()
            
        }
        
        // function for node-clicked events to redraw the graph and print the deck list
        function clicked(deck) {
            d3.selectAll("svg > *").remove();
            var resetButtonText =  svg.append("text")
                        .attr("x",649)
                        .attr("y",666)
                        .style("font-size","13px")
                        .text("Reset")
                var resetButton = svg.append("rect")
                        .on("click",function(d){redrawGraph()})
                        .attr("x",642)
                        .attr("y",653)
                        .attr("width",52)
                        .attr("height",17)
                        .attr("rx","4")
                        .style("fill","#faf9f4")
                        .style("fill-opacity",0)
                        .style("stroke","grey")
                        .style("stroke")
            var deckList = getDecklist(deck)
            //deckHistory.push(deckList)
            //console.log("clicked",deck)
            //console.log(deckList) // deckList has the list of cards in the chosen deck
            //console.log(decksJSON) // decksJSON has the X, Y coords, group, and names of decks


            // Redraw legend
            var nodeCircle = svg.append("circle")
                            .attr("cx",600)
                            .attr("cy",10)
                            .attr("r",8)
                            .style("fill","darkblue")
            var nodeCircle = svg.append("circle")
                            .attr("cx",600)
                            .attr("cy",35)
                            .attr("r",8)
                            .style("fill","darkgreen")
            var nodeCircle = svg.append("circle")
                            .attr("cx",600)
                            .attr("cy",60)
                            .attr("r",8)
                            .style("fill","darkred")
            var nodeLabel = svg.append("text")
                            .attr("x",610)
                            .attr("y",13)
                            .text("Aggro")
            var nodeLabel = svg.append("text")
                            .attr("x",610)
                            .attr("y",38)
                            .text("Combo")
            var nodeLabel = svg.append("text")
                            .attr("x",610)
                            .attr("y",63)
                            .text("Control")

            // redraws the graph with links to neighbors darkened and other links lightened
            var neighborList = []
            var nodeList = [deck]
            var nonneighborList = []
            var counter =0
            for (var i=0; i<linkData.length; i++){
                var deck1 = linkData[i]["source"]
                var deck2 = linkData[i]["target"]
                var strength = linkData[i]["value"]
                var x = 0
                // gets lighter and darker colors
                if ((deck1==deck||deck2==deck)) { 
                    x=create_color_dark(strength)
                    counter++
                    // creates node list for node coloring
                    if (deck1==deck) {
                        nodeList.push(deck2)
                    } else if (deck2==deck) {
                        nodeList.push(deck1)
                    } else {pass}
                } else {
                    x=create_color_light(strength)
                }
                

                if (deck2==deck){
                        deckTemp = deck2
                        deck2 = deck1
                        deck1 = deckTemp
                    }

                var color = d3.rgb(x,x,x)
                var deck1Stats = get_coord(deck1)
                var deck2Stats = get_coord(deck2)
                var x1 = deck1Stats[0]
                var x2 = deck2Stats[0]
                var y1 = deck1Stats[1]
                var y2 = deck2Stats[1]
                
                //draws non-neighbor links first, then links to neighbors to prevent overlap 
                if ((deck1==deck||deck2==deck)) { 
                    neighborList.push([x1,y1,x2,y2,color,deck1,deck2,strength])
                } else {
                    nonneighborList.push([x1,y1,x2,y2,color])
                }
            }

            for (i=0; i<nonneighborList.length; i++) {
                createEdge(nonneighborList[i][0],
                    nonneighborList[i][1],
                    nonneighborList[i][2],
                    nonneighborList[i][3],
                    nonneighborList[i][4],)
            }
            for (i=0; i<neighborList.length;i++) {
                createTippedEdge(neighborList[i][0],
                    neighborList[i][1],
                    neighborList[i][2],
                    neighborList[i][3],
                    neighborList[i][4],
                    neighborList[i][5],
                    neighborList[i][6],
                    neighborList[i][7])
            }

            for (var i=0; i<decksJSON.length; i++) {
                var deckname = decksJSON[i]["id"]
                var x = decksJSON[i]["x_value"]
                var y = decksJSON[i]["y_value"]
                var deckType = decksJSON[i]["group"]
                var rad = 10
                if (nodeList.indexOf(deckname)==-1){
                    createNodeLight(deckname,x,y,rad,deckType)
                } else {
                createNode(deckname,x,y,rad,deckType)
                }
            }
            
            // REFACTOR THIS BIT
            //var svg2 = d3.select('#canvas2').append('ul')
            var lines = []
            for (i=0; i<deckList.length; i++){
                line_array = [deckList[i]["quantity"],deckList[i]["card"]]
                lines.push(line_array)
            }
            deckHistory.push(deck)
            deckHistory.push(lines)
            if (deckHistory.length > 4) {
                deckHistory.shift()
                deckHistory.shift()
            }
            createDataTable(deckHistory)
            }
        

        function createDataTable(deckHistory) { 
            var deck_names = ["Card Name"]
            
            var temp_array = []
            var temp_full = []
            var deck1list = []
            var deck2list = []
            if (deckHistory.length == 2) {
                deck_names.push(deckHistory[0])
                for (j=0; j<deckHistory[1].length; j++){
                    temp_array.push([deckHistory[1][j][1],deckHistory[1][j][0]])
                }
            } else {
                deck_names.push(deckHistory[2])
                deck_names.push(deckHistory[0])
                for (j=0; j<deckHistory[1].length; j++){
                    
                    temp_full.push(deckHistory[1][j][1])
                    deck1list.push(deckHistory[1][j][1])
                }
                for (j=0; j<deckHistory[3].length; j++){
                    var n = temp_full.includes(deckHistory[3][j][1])
                    if (n == false) {
                        temp_full.push(deckHistory[3][j][1])
                    }

                deck2list.push(deckHistory[3][j][1])
                }

                temp_full.sort()
            }
            
            for (i=0; i<temp_full.length; i++) {
                var cardname = temp_full[i]
                var deck1_index = deck1list.indexOf(cardname)
                var deck2_index = deck2list.indexOf(cardname)
                var deck1val =0
                var deck2val =0
                if (deck1_index>-1){
                    deck1val = deckHistory[1][deck1_index][0]
                }
                if (deck2_index>-1){
                    deck2val = deckHistory[3][deck2_index][0]

                }
                temp_array.push([cardname,deck2val,deck1val])

                
            }

            createTable(deck_names,temp_array)
        }




        function createTable(columns,rawdata) {
            d3.selectAll("table > *").remove();
            data = []
            for (i=0; i<rawdata.length; i++){
                ttemp = {}
                for (j=0; j<columns.length; j++){
                    ttemp[columns[j]]=rawdata[i][j]
                }
                data.push(ttemp)
            }

            var table = d3.select('#canvas2').append('table')
            var thead = table.append('thead')
            var tbody = table.append('tbody')
            thead.append('tr')
                .selectAll('th')
                .data(columns).enter()
                .append('th')
                .text(function (column) { return column; });

            var tr = d3.select('tbody')
                .selectAll('tr')
                .data(data)
                .enter()
                .append('tr')
            var td = tr.selectAll('td')
                .data(function(d,i){
                    return Object.values(d)
                })
                .enter()
                .append('td')
                .text(function(d){return d})
        }
        

        function createEdge(x1,y1,x2,y2,color) {
            var nodeEdge = svg.append("line")
                            .attr("x1",x1)
                            .attr("x2",x2)
                            .attr("y1",y1)
                            .attr("y2",y2)
                            .attr("stroke-width",1.5)
                            //.attr("stroke",color)
                            .attr("stroke",color)
        }
        function createTippedEdge(x1,y1,x2,y2,color,deck1,deck2,strength) {
            var nodeEdge = svg.append("line")
                            .attr("x1",x1)
                            .attr("x2",x2)
                            .attr("y1",y1)
                            .attr("y2",y2)
                            .attr("stroke-width",3)
                            //.attr("stroke",color)
                            .attr("stroke",color)
                            .on("mouseover",function(d){
                                clearEdgeTip()
                                edgetooltip(deck1,deck2,strength)
                            })
        }

        function createNode(name,x,y,r,deckType){
            if (deckType === 1){
                var color = "darkblue"
            } else if (deckType === 2) {
                var color = "darkgreen"
            } else {var color = "darkred"}
            var nodeCircle = svg.append("circle")
                            .attr("cx",x)
                            .attr("cy",y)
                            .attr("r",r)
                            .style("fill",color)
                            .attr("id",name)
                            .on("mouseover",function(d){tooltip(name,x,y,r)})
                            .on("mouseout",function(d){cleartip()})
                            .on("click",function(d){clicked(name)})
                            //.on("click",function(d){console.log("You clicked "+name)})
            //console.log(nodeCircle)     
        }

        function createNodeLight(name,x,y,r,deckType){
            if (deckType === 1){
                var color = "lightblue"
            } else if (deckType === 2) {
                var color = "lightgreen"
            } else {var color = "#FF9898"}
            var nodeCircle = svg.append("circle")
                            .attr("cx",x)
                            .attr("cy",y)
                            .attr("r",r)
                            .style("fill",color)
                            .attr("id",name)
                            .on("mouseover",function(d){tooltip(name,x,y,r)})
                            .on("mouseout",function(d){cleartip()})
                            .on("click",function(d){clicked(name)})
                            //.on("click",function(d){console.log("You clicked "+name)})
            //console.log(nodeCircle)     
        }

        function create_color(x) {
            //console.log(x)
            x = Math.sqrt(x)
            x = Math.sqrt(x)
            y = Math.floor(Math.abs((x * 255)-255))
            return(y)
        }
        function create_color_dark(x) {
            x = Math.sqrt(x)
            x = Math.sqrt(x)
            x = Math.sqrt(x)
            y = Math.floor(Math.abs((x * 255)-255))
            return(y)
        }
        function create_color_light(x) {
            //y = Math.floor(Math.abs((x * 255)-255))
            return(192)
        }


        function get_coord(deckname) {
            for (var i=0; i<decksJSON.length; i++) { 
                if (decksJSON[i]["id"] === deckname) {
                    var x_value = decksJSON[i]["x_value"]
                    var y_value = decksJSON[i]["y_value"]
                }
                var tup = [x_value,y_value]
            }
            return(tup)
        }

    })
}

</script>

